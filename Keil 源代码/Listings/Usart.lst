C51 COMPILER V9.54   USART                                                                 03/21/2020 18:06:13 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\Usart.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Spring Program Files(x86)\MDK4 and MDK5\C51\BIN\C51.EXE Usart.c OPTIMIZE(8,S
                    -PEED) BROWSE INCDIR(..\Keil 源代码 - 副本) DEBUG OBJECTEXTEND PRINT(.\Listings\Usart.lst) TABS(2) OBJECT(.\Objects\Usart
                    -.obj)

line level    source

   1          
   2          
   3          
   4          #include "Usart.h"
   5          
   6          //串口初始化设置
   7          void Usart_Init(void)
   8          {
   9   1        SCON = 0x50;  //串口工作方式1
  10   1        TMOD = 0x20;    //定时器1工作方式2，8位自动重装初值
  11   1        TH1 = 0xfd;
  12   1        TL1 = 0xfd;
  13   1        ES = 1;   //允许串口接收中断
  14   1        TR1 = 1;  //定时器1开始计数，产生波特率时钟
  15   1        EA = 1;//开总中断
  16   1      
  17   1      }
  18          
  19          
  20          
  21          
  22          
  23          //把数据转换成字符串，并指定长度，不足前面补零,超出只取后面指定位数
  24          //不能转换0
  25          //最大只能转换20位
  26          //date:输入的数据 ；  Str_out：输出字符串首地址;  len:指定输出长度
  27          void ChangeString(uchar date,char *Str_out,uchar len)
  28          {
  29   1        uchar i=0;
  30   1        char string[20] = {0};//缓存转化的字符串
  31   1      
  32   1        for(i=0;i<20;i++)
  33   1        {
  34   2          string[i] = '0' + date%10;  //先存储最低位
  35   2          date /=10;
  36   2        }
  37   1      
  38   1        for(i=0;i<len;i++)
  39   1        {
  40   2          *(Str_out+i) = string[len-i-1];
  41   2        }
  42   1      }
  43          //StopFlag
  44          
  45          
  46          
  47          //发送一个数据帧出去
  48          void SendTheData(void)
  49          {
  50   1        uchar i;  //发送计数变量
  51   1        char str[17] = {0}; //整个数据帧
  52   1      
  53   1        char str1[5] = "smart"; //起始验证位
C51 COMPILER V9.54   USART                                                                 03/21/2020 18:06:13 PAGE 2   

  54   1        char str2[2] = {0}; //缓存温度值的字符串
  55   1        char str3[2] = {0}; //缓存湿度值的字符串
  56   1        char str4[2] = {0}; //缓存烟雾浓度值的字符串
  57   1        char str5[2] = {0}; //缓存危险等级
  58   1        char str6[1] = {0}; //危险类型
  59   1        char str7[1] = {0};//消防管道开合状态
  60   1        char str8[2] = "ok";  //结束标志位
  61   1      
  62   1        
  63   1        //将校验标识以及数据转换成字符添加到字符串里面
  64   1        strcpy(str,str1); //添加起始位，5位，用于验证用户   //起始0
  65   1        
  66   1        ChangeString(temperature,str2,2);
  67   1        strncat(str,str2,2);  //在后面拼接温度值            //起始5
  68   1        
  69   1        ChangeString(humidity,str3,2);
  70   1        strncat(str,str3,2);//在后面拼接湿度值              //起始7
  71   1        
  72   1        ChangeString(smoke,str4,2);
  73   1        strncat(str,str4,2);//在后面拼接烟雾浓度值          //起始9
  74   1        
  75   1        ChangeString(DangerLevel,str5,2);
  76   1        strncat(str,str5,2);//拼接危险等级                  //起始11
  77   1        
  78   1        ChangeString(DangerType,str6,1);
  79   1        strncat(str,str6,1);//在后面拼接危险类型            //起始13
  80   1        
  81   1        ChangeString(Angle,str7,1);
  82   1        strncat(str,str7,1);//在后面拼接消防管道开合状态    //起始14
  83   1        
  84   1        strcat(str,str8);//在后面拼接消防管道开合角度       //起始15
  85   1      
  86   1        for(i=0;i<16;i++)
  87   1        {
  88   2          SBUF = str[i];
  89   2          while(TI == 0); //等待一个byte发送完成后，TI由硬件置1
  90   2          TI = 0; //清除标志位，准备下一次发送
  91   2      
  92   2        }
  93   1      
  94   1      
  95   1      }
  96          //End of Function


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    575    ----
   CONSTANT SIZE    =     54    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      60
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
